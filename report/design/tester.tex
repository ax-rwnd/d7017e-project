% intro, what is Tester trying to do?
% we want broad language support
Tester is a tool for testing code in a variety of programming languages in a safe and isolated environment. To fulfill the needs of the GPP, Tester needs to support a  broad varierty of languages, so that the range of courses that can benefit from the platform is not limited. Tester also strives for the functionality to test code based on different merits to support the creation of varied, fun and interesting assignments.

\subsection{Sandboxing}
%TODO ref to docker
An important feature of Tester is that the code is tested in an isolated environment. The main reason behind doing this is that we are executing potentially malicious code. Allowing such code to be executed without isolation is bound to cause service disruptions or information leaks.

To achieve isolation all code testing takes place in so called Docker containers equipped with the tools necessary to compile and run the code. A container is a virtualization (simulation) of an operating-system with a separate user-space. What this means is that programs running inside the container can only access the contents and devices that are assigned to the container. By running the tests in Docker containers, any malicious code cannot gain access to information it shouldn't have access to or cause any disruptions to the service, since such code will at most crash the container which has no long-lasting effects on the service offered by Tester.
\subsection{Manager}
% add discussion of different ways of managing load and what we chose
% (Start containers on demand? Keep a pool of containers ready? Predict load or just react? Allocate different amounts of resources for different languages?)

As Backend sends requests to Tester these requests are handled by assigning a free container to serve that request.
If all containers for a language are busy, requests for that language are enqueued. 
The containers take around one second to start. In order to decrease the response time to backend,
containers are started preemptively. Once a request has been served another container of the same type is started.

If Tester receives a lot of requests, it will in turn start large number of containers.
Starting too many containers will affect the overall performance of the system and therefore performance per container.
This will increase the uncertainty of the timing tests which is undesirable.

In order to address this issue the Manager has to keep track of which containers
are started and which ones which are currently processing a request. 
It is possible to configure the maximum number of containers that
can be started and to specify the maximum number of containers
per supported language. It is also possible to configure the number of containers
that should be started even if no request for that language has been made to keep
idling containers ready serve new requests. This is done in order to decrease
response time to Backend.

Another way of handling the number of containers running at a given time could
be to predict demand for different languages and start more containers for popular languages.
This has not been implemented but could be done in the future.

Each container is limited to one thread of the processor running at 50\% core speed and
100MB memory. Because of this each time a student runs the same code a similar
result can be observed. Timing is always a difficult property to measure but with
these settings Tester can deliver similar timings multiple times.

If a container is hijacked by malicious code the Manager has a timeout that will
force the container to exit and respond with an error.

\subsection{Test types}
% unit tests are hard to write
% I/O tests are language-independent which is good if we want broad language support
Currently, Tester supports three types of tests:
\begin{itemize}
\item Input/Output (I/O). The submitted code is supplied with some input (either through standard in or commandline arguments) and the output is compared to what the code is expected to output.
\item Code size. These tests enforce a maximum limit on the number of characters there can be in the submitted code.
\item Lint. A lint test makes sure that the submitted code adheres to some coding standard for the language. Indentation, trailing whitespaces and blank lines are some examples of what might be checked.
\end{itemize}

When deciding which test types had the highest implementation priority, an important factor was the time expenditure required by the creator of the tests. If writing tests for a single assignment takes a considerable amount of time the platform will become impractical to use. For this reason tests such as Unit Tests are not supported. It would be time-consuming for lab supervisors to write tests.

Another deciding factor is the language-dependency of the unit tests. If a test requires language-specific implementation the extensibility of the language support suffers. This is one of the reasons why the I/O and Code size tests mentioned allow are excellent choices, they are both language-independent and require no additional implementation for every language supported. Although Lint tests are not language-independent, they have been implemented for a few languages as a proof of concept.

\subsection{Extensibility}
In order to achieve broad language support, it needs to be easy to add new languages. Two steps are necessary to add support for a new language:

\begin{itemize}
\item The manager has a makefile that produces docker images for each supported language. The makefile needs to be extended with a new target that installs language-specific dependencies.

\item The Node instance running in the container needs to have a module for each supported language. Each language module exports two functions: \texttt{prepare}, which produces a file that can be run with the \texttt{run} function. The \texttt{prepare} step is used for compiled languages, where a binary must be produced before running the program. Some languages, such as python, are run directly in the interpreter. By making preparation a separate step, the program does not need to be recompiled for each test.
\end{itemize}

\subsection{Service Availability Fallback}
A little known feature of Tester is that it plays nice with load-balancers by reporting whether or not the testing service itself is available. That is, if the language that is to be tested isn't available, or the testing-queue is full, it defers the job to another Tester. It does that by responding with the \texttt{503: Service Unavailable} status, after which the load-balancer sitting in front of it will understand that it needs to route traffic elsewhere.
